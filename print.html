<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>tlsn-docs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Protocol</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="protocol/notarization/index.html"><strong aria-hidden="true">2.</strong> Notarization</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> TLS Handshake</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/notarization/key_exchange.html"><strong aria-hidden="true">2.1.1.</strong> Key Exchange</a></li><li class="chapter-item expanded "><a href="protocol/notarization/prf.html"><strong aria-hidden="true">2.1.2.</strong> Symmetric key derivation</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> (Enc/Dec)ryption</div></li><li class="chapter-item expanded "><a href="protocol/notarization/commitment.html"><strong aria-hidden="true">2.3.</strong> Commitment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/notarization/public_data_commitment.html"><strong aria-hidden="true">2.3.1.</strong> Commitment to public data</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Selective Disclosure</div></li><li class="chapter-item expanded "><a href="protocol/2pc/garbled_circuits.html"><strong aria-hidden="true">4.</strong> Secure 2-Party Computation</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Garbled Circuits</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/2pc/dual_execution.html"><strong aria-hidden="true">4.1.1.</strong> Dual Execution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/2pc/dual_execution_with_privacy_only_for_the_user.html"><strong aria-hidden="true">4.1.1.1.</strong> Dual Execution with privacy only for the User</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Oblivious Transfer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Paillier</div></li><li class="chapter-item expanded "><a href="protocol/2pc/mac.html"><strong aria-hidden="true">4.4.</strong> MAC</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">tlsn-docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notarization-phase"><a class="header" href="#notarization-phase">Notarization Phase</a></h1>
<p>During the Notarization Phase the <code>Requester</code>, otherwise referred to as the <code>User</code>, and the <code>Notary</code> work together to generate an authenticated <code>Transcript</code> of a TLS session with a <code>Server</code>.</p>
<p>Listed below are some key points regarding this process:</p>
<ul>
<li>The identity of the <code>Server</code> is not revealed to the <code>Notary</code>, but the <code>Requester</code> is capable of proving the <code>Server</code> identity to a <code>Verifier</code> later.</li>
<li>The <code>Notary</code> only ever sees the <em>encrypted</em> application data of the TLS session.</li>
<li>The protocol guarantees that the <code>Requester</code> is not solely capable of constructing requests, nor can they forge responses from the <code>Server</code>.</li>
</ul>
<h2 id="requester"><a class="header" href="#requester">Requester</a></h2>
<p>The <code>Requester</code> is the party which runs the TLS connection with the <code>Server</code>. The <code>Requester</code> constructs application payloads, eg. HTTP requests, and coordinates with the <code>Notary</code> to encrypt them with the TLS session keys prior to sending them. Subsequently, the <code>Requester</code> works with the <code>Notary</code> to decrypt responses from the <code>Server</code>. The plaintext of the application data is only ever revealed to the <code>Requester</code>.</p>
<h2 id="notary"><a class="header" href="#notary">Notary</a></h2>
<p>The <code>Notary</code> is the party of which the authenticity of the <code>Transcript</code> relies on. During the session the <code>Notary</code> withholds its' shares of the TLS keys and participates in a series of secure 2-party computation protocols with the <code>Requester</code> to operate the TLS connection.</p>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>The <code>Server</code> can be any server which supports TLS. The TLSNotary protocol is entirely transparent to the <code>Server</code>, thus it can not be censored nor does it have to support any additional functionality.</p>
<img src="https://raw.githubusercontent.com/tlsnotary/docs-assets/main/diagrams/tls12-multiround.png">
<h2 id="transcript"><a class="header" href="#transcript">Transcript</a></h2>
<p>The primary artifact generated from this phase is called the <code>Transcript</code>. It contains session meta-data, handshake data, and commitments to all the requests and responses. Typically the <code>Transcript</code> is signed by the <code>Notary</code>, however that is not necessary in the case where the <code>Notary</code> will also act as the <code>Verifier</code> in the selective disclosure phase.</p>
<blockquote>
<p>Note that the server ephemeral key does not reveal the identity of the server to the <code>Notary</code>.</p>
</blockquote>
<img src="https://raw.githubusercontent.com/tlsnotary/docs-assets/main/diagrams/transcript.png"><div style="break-before: page; page-break-before: always;"></div><h1 id="key-exchange"><a class="header" href="#key-exchange">Key Exchange</a></h1>
<p>In TLS, the first step towards obtaining TLS session keys is to compute a shared secret between the client and the server by running the <a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">ECDH protocol</a>. The resulting shared secret in TLS terms is called the pre-master secret <code>PMS</code>.</p>
<img src="https://raw.githubusercontent.com/tlsnotary/docs-assets/main/diagrams/key_exchange.png" width="800">
<p>Using the notation from Wikipedia, below is the 3-party ECDH protocol between the <code>Server</code> the <code>Requester</code> and the <code>Notary</code>, enabling the <code>Requester</code> and the <code>Notary</code> to arrive at shares of <code>PMS</code>.</p>
<ol>
<li><code>Server</code> sends its public key \(\small{Q_b}\) to <code>Requester</code>, and <code>Requester</code> forwards it to <code>Notary</code></li>
<li><code>Requester</code> picks a random private key share \( \small{d_c} \) and computes a public key share \( \small{Q_c = d_c * G} \)</li>
<li><code>Notary</code> picks a random private key share \( \small{d_n} \) and computes a public key share \( \small{Q_n = d_n * G} \)</li>
<li><code>Notary</code> sends \( \small{Q_n} \) to <code>Requester</code> who computes \( \small{Q_a = Q_c + Q_n} \) and sends \( \small{Q_a} \) to <code>Server</code></li>
<li><code>Requester</code> computes an EC point \( \small{(x_p, y_p) = d_c * Q_b} \)</li>
<li><code>Notary</code> computes an EC point \( \small{(x_q, y_q) = d_n * Q_b} \)</li>
<li>Addition of points \( \small{(x_p, y_p)} \) and \( \small{(x_q, y_q)} \) results in the coordinate \( \small{x_r} \), which is <code>PMS</code>. (The coordinate \( \small{y_r} \) is not used in TLS)</li>
</ol>
<p>Using the notation from <a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_addition">here</a>, our goal is to compute
\[ \tag{1} x_r = (\frac{y_q-y_p}{x_q-x_p})^2 - x_p - x_q \]
in such a way that</p>
<ol>
<li>Neither party learns the other party's \( \small{x} \) value</li>
<li>Neither party learns \( \small{x_r} \), only their respective shares of \( \small{x_r} \).</li>
</ol>
<p>Let's start out by simplifying the equation</p>
<p>\[\tag{2} x_r = (y_q^2 - 2y_q y_p + y_p^2)(x_q - x_p)^{-2} - x_p - x_q \bmod p \]</p>
<p>Since this is finite field arithmetic, if \( \small{x_r &gt; p} \) we must reduce \( \small{x_r} \) modulo \( \small{p} \), i.e assign \( \small{x_r} \) the value \( \small{x_r \bmod p} \). The trailing \( \small{\bmod p} \) is always implied from here on out, but may be omitted for brevity.</p>
<blockquote>
<p>For the curious, the modulus of the most common EC curve P-256 is a prime number and its value is \( \small{p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1}\)</p>
</blockquote>
<p>Based on <a href="https://en.wikipedia.org/wiki/Fermat&#x27;s_little_theorem">Fermat's little theorem</a>:</p>
<p>\[ a^{-2} \bmod p = a^{p-3} \bmod p \]</p>
<p>Replacing the negative power of Equation (2), we get:</p>
<p>\[\tag{3} x_r = (y_q^2 - 2y_q y_p + y_p^2)(x_q - x_p)^\color{red}{p-3} - x_p - x_q \]</p>
<p>We then proceed to decompose Equation (3) into discrete parts:</p>
<p>\[ \tag{4} A = (y_q^2 - 2y_q y_p + y_p^2) \\\
B = (x_q - x_p)^{p-3} \\\
C = - x_p - x_q \]</p>
<h2 id="computing--smalla--y_q2---2y_q-y_p--y_p2-"><a class="header" href="#computing--smalla--y_q2---2y_q-y_p--y_p2-">Computing \( \small{A = (y_q^2 - 2y_q y_p + y_p^2)} \)</a></h2>
<p><code>Notary</code>:</p>
<ol>
<li>Sends \( \small{E(y_q^2)} \) and \( \small{E(-2y_q)} \)</li>
</ol>
<p><code>Requester</code>:</p>
<ol start="2">
<li>Computes \( \small{E(y_p^2)} \)</li>
<li>Computes \( \small{E(A) = E(y_q^2) + E(-2y_q) * y_p + E(y_p^2)} \)</li>
<li>Generates random masks \( \small{M_A} \) and \( \small{N_A} \) and computes \( \small{E(A * M_A + N_A)} \)</li>
<li>Sends \( \small{E(A * M_A + N_A)} \) and \( \small{(N_A \bmod p)} \)</li>
</ol>
<blockquote>
<p>Note that here \( \small{N_A} \) (as well as \( \small{N_b} \) and \( \small{N_B} \) below) is crucial, as without it <code>Notary</code> would be able to factorize \( \small{A * M_A} \) and learn \( \small{A} \)</p>
</blockquote>
<p><code>Notary</code>:</p>
<ol start="6">
<li>Decrypts and gets \( \small{(A * M_A + N_A)} \)</li>
<li>Reduces \( \small{(A * M_A + N_A) \bmod p} \)</li>
<li>Computes \( \small{(A * M_A) \bmod p = (A * M_A + N_A) \bmod p - N_A \bmod p} \)</li>
</ol>
<h2 id="computing--smallb--x_q---x_pp-3-"><a class="header" href="#computing--smallb--x_q---x_pp-3-">Computing \( \small{B = (x_q - x_p)^{p-3}} \)</a></h2>
<p><code>Notary</code>:</p>
<ol>
<li>Sends \( \small{E(x_q)} \)</li>
</ol>
<p><code>Requester</code>:</p>
<ol start="2">
<li>Lets \( \small{b = x_q - x_p} \)</li>
<li>Computes \( \small{E(-x_p)} \)</li>
<li>Computes \( \small{E(b) = E(x_q) + E(-x_p)} \)</li>
<li>Generates random masks \( \small{M_b} \) and \( \small{N_b} \) and computes \( \small{E(b * M_b + N_b)} \)</li>
<li>Sends \( \small{E(b * M_b + N_b)} \) and \( \small{(N_b \bmod p)} \)</li>
</ol>
<p><code>Notary</code>:</p>
<ol start="7">
<li>Decrypts and gets \( \small{(b * M_b + N_b)} \)</li>
<li>Reduces \( \small{(b * M_b + N_b) \bmod p} \)</li>
<li>Computes \( \small{(b * M_b) \bmod p = (b * M_b + N_b) \bmod p - N_b \bmod p} \)</li>
<li>Sends \( \small{E((b * M_b)^{p-3} \bmod p)} \)</li>
</ol>
<p><code>Requester</code>:</p>
<ol start="11">
<li>Computes multiplicative inverse \( \small{inv = (M_b^{p-3})^{-1} \bmod p} \)</li>
<li>Computes \( \small{E((b * M_b)^{p-3} \bmod p) * inv = E(b^{p-3} * (M_b^{p-3})^{-1}) = E(b^{p-3}) = E(B)} \)</li>
<li>Generates random masks \( \small{M_B} \) and \( \small{N_B)} \) and computes \( \small{E(B * M_B + N_B)} \)</li>
<li>Sends \( \small{E(B * M_B + N_B)} \) and \( \small{N_B \bmod p} \)</li>
</ol>
<p><code>Notary</code>:</p>
<ol start="15">
<li>Decrypts and gets \( \small{(B * M_B + N_B)} \)</li>
<li>Reduces \( \small{(B * M_B + N_B) \bmod p} \)</li>
<li>Computes \( \small{(B * M_B) \bmod p = (B * M_B + N_B) \bmod p - N_B \bmod p} \)</li>
</ol>
<h2 id="computing--smallx_r--a--b--c-"><a class="header" href="#computing--smallx_r--a--b--c-">Computing \( \small{x_r = A * B + C} \)</a></h2>
<p><code>Notary</code>:</p>
<ol>
<li>Sends \( \small{E(A * M_A * B * M_B)} \) and \( \small{E(-x_q)} \)</li>
</ol>
<p><code>Requester</code>:</p>
<ol start="2">
<li>Computes \( \small{E(A * B) = E(A * M_A * B * M_B) * (M_A * M_B)^{-1}} \) and \( \small{E(-x_p)} \)</li>
<li>Computes \( \small{E(A * B + C) = E(A * B) + E(-x_q) + E(-x_p)} \)</li>
<li>Generates and applies a random mask \( \small{E(S_q)} \) and sends \( \small{E(A * B + C + S_q)} \)</li>
<li>Computes additive <code>PMS</code> share \( \small{s_q = (S_q \bmod p)} \)</li>
</ol>
<p><code>Notary</code>:</p>
<ol start="6">
<li>Decrypts and gets \( \small{A * B + C + S_q} \)</li>
<li>Computes additive <code>PMS</code> share \( \small{s_p = (A * B + C + S_q) \bmod p} \)</li>
</ol>
<p>The protocol described above is secure against <code>Notary</code> sending malicious inputs. Indeed, because <code>Requester</code> only sends back masked values, <code>Notary</code> cannot learn anything about those values.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>The pre-master secret (<code>PMS</code>) must be put through a <code>PRF</code> (pseudo-random function) defined by the TLS spec in order to compute the symmetric TLS keys and also to compute the <code>verify_data</code> for the <code>Client_Finished</code> and the <code>Server_Finished</code> messages.</p>
<p>Below we describe how the parties (<code>N</code> stands for <code>Notary</code> and <code>U</code> stands for <code>User</code>) who have their shares of <code>PMS</code> can use 2PC to compute the <code>PRF</code>. </p>
<blockquote>
<p>Since the TLSNotary protocol already uses Garbled Circuits and Oblivious Transfer which give 128-bit computational security for the parties against each other, we argue that it is acceptable to perform some PRF computations outside of 2PC as long as it is done with at least 128-bit security.
Performing some PRF computations outside of 2PC allows to save on computation and bandwidth.</p>
</blockquote>
<blockquote>
<p>Note that the User's TLS connection retains the standard TLS security guarantees against any third-party adversary. </p>
</blockquote>
<p>To elaborate, recall how <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a> is computed (assuming |k| &lt;= block size):</p>
<pre><code>HMAC(k, m) = H((k ⊕ opad) | H((k ⊕ ipad) | m))
</code></pre>
<p>Notice that both H(k ⊕ opad) and H(k ⊕ ipad) can be computed separately prior to finalization. In this
document we name these units as such:</p>
<ul>
<li><code>outer hash state</code>: H(k ⊕ opad)</li>
<li><code>inner hash state</code>: H(k ⊕ ipad)</li>
<li><code>inner hash</code>: H((k ⊕ ipad) | m)</li>
</ul>
<p>In TLS, the master secret is computed like so:</p>
<pre><code class="language-python">seed = &quot;master secret&quot; | client_random | server_random
a0 = seed
a1 = HMAC(pms, a0)
a2 = HMAC(pms, a1)
p1 = HMAC(pms, a1 | seed)
p2 = HMAC(pms, a2 | seed)
ms = (p1 | p2)[:48]
</code></pre>
<p>Notice that in each step the key, in this case <code>PMS</code>, is constant. Thus both the <code>outer</code> and <code>inner hash state</code> can be reused for each step.</p>
<p>Below is the description of the all the steps to compute the <code>PRF</code> both inside and outside the 2PC circuit.</p>
<h2 id="-----computing-the-master-secret"><a class="header" href="#-----computing-the-master-secret">---- Computing the master secret</a></h2>
<h3 id="---inside-the-circuit"><a class="header" href="#---inside-the-circuit">-- Inside the circuit</a></h3>
<ol>
<li>To evaluate the circuit, the parties input their <code>PMS</code> shares. The circuit outputs:</li>
</ol>
<ul>
<li>H(PMS ⊕ opad) called <code>PMS</code> <code>outer hash state</code> to <code>N</code> and</li>
<li>H(PMS ⊕ ipad) called <code>PMS</code> <code>inner hash state</code> to <code>U</code></li>
</ul>
<h3 id="---outside-the-circuit"><a class="header" href="#---outside-the-circuit">-- Outside the circuit</a></h3>
<ol start="2">
<li>
<p><code>U</code> computes H((PMS ⊕ ipad) || a0) called <code>inner hash</code> of <code>a1</code> and passes it to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> computes <code>a1</code> and passes it to <code>U</code>.</p>
</li>
<li>
<p><code>U</code> computes the <code>inner hash</code> of <code>a2</code> and passes it to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> computes <code>a2</code> and passes it to <code>U</code>.</p>
</li>
<li>
<p><code>U</code> computes the <code>inner hash</code> of p2 and passes it to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> computes <code>p2</code> and passes it to <code>U</code>.
&gt;Note that now both parties know <code>p2</code> which is the last 16 bytes of the master secret. They still don't know the other 32 bytes of the master secret, which ensures adequate security.</p>
</li>
<li>
<p><code>U</code> computes the <code>inner hash</code> of <code>p1</code>.</p>
</li>
</ol>
<h3 id="---inside-the-circuit-1"><a class="header" href="#---inside-the-circuit-1">-- Inside the circuit</a></h3>
<ol start="9">
<li>To evaluate the circuit, <code>N</code> inputs the <code>PMS outer hash state</code> and <code>U</code> inputs <code>p2</code> and the <code>inner hash</code> of <code>p1</code>. The circuit computes the master secret (<code>MS</code>).</li>
</ol>
<h2 id="-----computing-the-expanded-keys"><a class="header" href="#-----computing-the-expanded-keys">---- Computing the expanded keys</a></h2>
<p>The parties proceed to compute the <code>expanded keys</code>. The corresponding python code is:</p>
<pre><code class="language-python">seed = str.encode(&quot;key expansion&quot;) + server_random + client_random
a0 = seed
a1 = hmac.new(ms , a0, hashlib.sha256).digest()
a2 = hmac.new(ms , a1, hashlib.sha256).digest()
p1 = hmac.new(ms, a1+seed, hashlib.sha256).digest()
p2 = hmac.new(ms, a2+seed, hashlib.sha256).digest()
ek = (p1 + p2)[:40]
client_write_key = ek[:16]
server_write_key = ek[16:32]
client_write_IV = ek[32:36]
server_write_IV = ek[36:40]
</code></pre>
<h3 id="---inside-the-circuit-2"><a class="header" href="#---inside-the-circuit-2">-- Inside the circuit</a></h3>
<ol start="10">
<li>Having computed <code>MS</code>, the circuit outputs:</li>
</ol>
<ul>
<li>H(MS ⊕ opad) called the <code>MS outer hash state</code> to <code>N</code> and</li>
<li>H(MS ⊕ ipad) called the <code>MS inner hash state</code> to <code>U</code></li>
</ul>
<h3 id="---outside-the-circuit-1"><a class="header" href="#---outside-the-circuit-1">-- Outside the circuit</a></h3>
<ol start="11">
<li>
<p><code>U</code> computes the <code>inner hash</code> of <code>a1</code> and sends it to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> computes <code>a1</code> and sends it to <code>U</code>.</p>
</li>
<li>
<p><code>U</code> computes the <code>inner hash</code> of <code>a2</code> and sends it to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> computes <code>a2</code> and sends it to <code>U</code>.</p>
</li>
<li>
<p><code>U</code> computes the <code>inner hash state</code> of <code>p1</code> and the <code>inner hash state</code> of <code>p2</code>.</p>
</li>
</ol>
<h3 id="---inside-the-circuit-3"><a class="header" href="#---inside-the-circuit-3">-- Inside the circuit</a></h3>
<ol start="16">
<li>To evaluate the circuit, <code>N</code> inputs <code>MS outer hash state</code> (from Step 10) and <code>U</code> inputs <code>inner hash state</code> of <code>p1</code> and <code>inner hash state</code> of <code>p2</code>. The circuit computes <code>p1</code> and <code>p2</code>. The circuit outputs xor shares of the <code>expanded keys</code> to each party.</li>
</ol>
<h2 id="-----computing-the-encrypted-client_finished"><a class="header" href="#-----computing-the-encrypted-client_finished">---- Computing the encrypted Client_Finished</a></h2>
<h3 id="---inside-the-circuit-4"><a class="header" href="#---inside-the-circuit-4">-- Inside the circuit</a></h3>
<ol start="17">
<li>To evaluate the circuit, the parties input their shares of the <code>expanded keys</code>. The circuit outputs data needed to encrypt and authenticate the <code>Client_Finished</code> (<code>CF</code>) message.</li>
</ol>
<h3 id="---outside-the-circuit-2"><a class="header" href="#---outside-the-circuit-2">-- Outside the circuit</a></h3>
<p>The parties proceed to compute <code>verify_data</code> for the <code>CF</code> message. The corresponding python code is:</p>
<pre><code class="language-python"># (handshake_hash) is a sha256 hash of all TLS handshake message up to this point
seed = str.encode('client finished') + handshake_hash
a0 = seed
a1 = hmac.new(ms, a0, hashlib.sha256).digest()
p1 = hmac.new(ms, a1+seed, hashlib.sha256).digest()
verify_data = p1[:12]
</code></pre>
<ol start="18">
<li>
<p><code>U</code> computes <code>inner hash</code> of <code>a1</code> and sends it to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> (who has <code>MS</code> <code>outer hash state</code> from Step 10) computes <code>a1</code> and sends it to <code>U</code>.</p>
</li>
<li>
<p><code>U</code> computes <code>inner hash</code> of <code>p1</code> and sends it to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> computes <code>p1</code> and gets <code>verify_data</code> and sends it to <code>U</code>.</p>
</li>
</ol>
<blockquote>
<p>Note that it is safe for <code>N</code> to know <code>verify_data</code> for <code>CF</code>. </p>
</blockquote>
<p>Using the data from Step 17, <code>U</code> proceeds to encrypt and authenticate <code>CF</code> and sends it to the webserver.</p>
<h2 id="-----verifying-the-server_finished"><a class="header" href="#-----verifying-the-server_finished">---- Verifying the Server_Finished</a></h2>
<p>Upon <code>U</code>'s receiving the encrypted <code>Server_Finished</code> (<code>SF</code>) from the webserver, the parties proceed to compute <code>verify_data</code> for <code>SF</code>, to enable <code>U</code> to check that the received <code>SF</code> is correct. The corresponding python code is:</p>
<pre><code class="language-python"># (handshake_hash) is a sha256 hash of all TLS handshake message up to this point
seed = str.encode('server finished') + handshake_hash
a0 = seed
a1 = hmac.new(ms, a0, hashlib.sha256).digest()
p1 = hmac.new(ms, a1+seed, hashlib.sha256).digest()
verify_data = p1[:12]
</code></pre>
<h3 id="---outside-the-circuit-3"><a class="header" href="#---outside-the-circuit-3">-- Outside the circuit</a></h3>
<ol start="22">
<li>
<p><code>U</code> computes <code>inner hash</code> of <code>a1</code> and sends it to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> (who has <code>MS</code> <code>outer hash state</code> from Step 10) computes <code>a1</code> and sends it to <code>U</code>.</p>
</li>
<li>
<p><code>U</code> computes <code>inner hash</code> of <code>p1</code>.</p>
</li>
</ol>
<h3 id="---inside-the-circuit-5"><a class="header" href="#---inside-the-circuit-5">-- Inside the circuit</a></h3>
<ol start="25">
<li>To evaluate the circuit, <code>N</code> inputs <code>MS</code> <code>outer hash state</code> (from Step 10) and <code>U</code> inputs <code>inner hash</code> of <code>p1</code>. The circuit outputs <code>verify_data</code> for <code>SF</code> to <code>U</code>.</li>
</ol>
<p>The parties proceed to decrypt and authenticate the <code>SF</code> in 2PC. <code>U</code> checks that <code>verify_data</code> from <code>SF</code> matches <code>verify_data</code> from Step 25.</p>
<div style="break-before: page; page-break-before: always;"></div><p>At the end of the TLSNotary protocol, the User has the authenticated AES ciphertext which can be thought of as a commitment to the plaintext. This form of commitment is not amenable to use cases when the User wants to make part of the plaintext public while keeping another part private. Naively, the User's option is to prove the decryption of the ciphertext in zero-knowledge which is computationally expensive.</p>
<p>We describe two less computationally heavy approaches for converting the AES ciphertext commitments. </p>
<p>The first approach is useful for commitments to the data which the User intends to make public. It is based on decrypting the ciphertext with Garbled Circuits and producing a hash commitment to the wire labels.</p>
<p>The second approach is useful for commitments to the private data which the User later intends to prove statements about in zero-knowledge. This approach produces a Poseidon hash over the private data. </p>
<div style="break-before: page; page-break-before: always;"></div><p>We describe an interactive protocol between the User <code>U</code> and the Notary <code>N</code>, whereby <code>U</code> can convert the authenticated AES ciphertext into a hash commitment to Garbled Circuits wire labels.</p>
<h3 id="-----creating-the-new-commitment"><a class="header" href="#-----creating-the-new-commitment">---- Creating the new commitment</a></h3>
<ol start="0">
<li>
<p>At the end of the TLSNotary session, both <code>U</code> and <code>N</code> know the authenticated AES <code>ciphertext</code>. </p>
</li>
<li>
<p><code>N</code> reveals his TLS session key shares to <code>U</code>.</p>
</li>
<li>
<p><code>U</code> decrypts the <code>ciphertext</code> in the clear and learns the plaintext <code>p</code>.</p>
</li>
<li>
<p><code>N</code> picks a <code>seed</code> and uses it as the source of randomness to generate (in the semi-honest model) a privacy-free garbled circuit whose functionality is to accept the plaintext input, encrypt it, and output the ciphertext. </p>
</li>
<li>
<p>With <code>p</code> as her circuit input, <code>U</code> receives input wire labels <code>IWLs</code> via Oblivious Transfer and then evaluates the circuit on those <code>IWLs</code>. The result of the evaluation are output wire labels <code>OWLs</code> which <code>U</code> does not know the decoding for.</p>
</li>
<li>
<p><code>U</code> sends two commitments: <code>commitment to IWLs</code> and <code>commitment to OWLs</code> to <code>N</code>.</p>
</li>
<li>
<p><code>N</code> reveals the <code>seed</code> and <code>U</code> checks that the circuit (including its <code>IWLs</code> and <code>OWLs</code>) was generated correctly and, if successful, reveals her <code>OWLs</code>.</p>
</li>
<li>
<p><code>N</code> verifies <code>commitment to OWLs</code> and then checks that decoded <code>OWLs</code> match the <code>ciphertext</code> (from Step 0) and, if successful, signs (<code>seed</code> + <code>commitment to IWLs</code>). </p>
</li>
</ol>
<blockquote>
<p>Now, (<code>seed</code> + <code>commitment to IWLs</code>) become <code>U</code>'s new commitment to <code>p</code>.</p>
</blockquote>
<h3 id="-----verifying-the-commitment"><a class="header" href="#-----verifying-the-commitment">---- Verifying the commitment</a></h3>
<p>Verifier performs the following steps:</p>
<ol>
<li>
<p>Receives the following from <code>U</code>: plaintext <code>p</code>, <code>signature</code> for (<code>seed</code> + <code>commitment to IWLs</code>), <code>seed</code>, <code>commitment to IWLs</code>.</p>
</li>
<li>
<p>(using a trusted <code>N</code>s pubkey) Verifies the <code>signature</code>.</p>
</li>
<li>
<p>Re-generates the <code>IWLs</code> from the <code>seed</code>.</p>
</li>
<li>
<p>Picks only those <code>IWLs</code> which correspond to <code>p</code> and checks that the commitment to those <code>IWLs</code> matches <code>commitment to IWLs</code>.</p>
</li>
<li>
<p>Accepts <code>p</code> as authentic.</p>
</li>
</ol>
<h3 id="-----dynamic-commitment-using-a-merkle-tree"><a class="header" href="#-----dynamic-commitment-using-a-merkle-tree">---- Dynamic commitment using a Merkle tree</a></h3>
<p>In situations where <code>U</code> does not know in advance which subset of the public data she will be revealing later to the Verifier, <code>U</code> can commit to the Merkle tree of all her input wire labels (from Step 4 above). 
Later, <code>U</code> can reveal only those Merkle leaves which she wants to make public to the Verifier. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-2-party-computation"><a class="header" href="#secure-2-party-computation">Secure 2-Party Computation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>To ensure malicious security of the Garbled Circuits 2PC, TLSNotary uses the <a href="https://securecomputation.org/docs/pragmaticmpc.pdf">Dual Execution protocol</a> (see Section 7.6).</p>
<p>DualEX inherently leaks one bit of private input with probability 1/2. This is not a problem during the TLS handshake when the private inputs are symmetric keys or hash pre-images. Leaking 1 bit does not give the adversary any advantage, since with the same probability the adversary may have guessed that bit while brute-forcing the key or the pre-image.</p>
<p>However, the leakage becomes a problem when encrypting the request or decrypting the response, since leaking even 1 bit of the plaintext may be catastrophic for the User's privacy. To overcome this leakage, we use a variant of DualEx where privacy is guaranteed only for the User.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>When encrypting the plaintext request in Dual Execution 2PC, the User can avoid the inherent 1-bit leakage of her plaintext by having the Notary give up his private inputs at the end of the TLSNotary session and also introducing some correctness checks. The technical steps of this approach are given below. </p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The User wants to encrypt a TLS request with some server, but she doesn't have the encryption key. Rather she has just one share of the key. The Notary has the other share. The Notary needs to know that the only ciphertext sent to the TLS server is the ciphertext he has seen (it would be bad, e.g., if the User had the full key because she'd lie to the Notary about the request she sent). We want a 2PC scheme that will allow the User and Notary to collaboratively compute the ciphertext such that: the User does not reveal her plaintext or key share, and the Notary does not reveal his key share.</p>
<h2 id="observations"><a class="header" href="#observations">Observations</a></h2>
<p>We make two observations. Firstly, a small amount of keyshare leakage is tolerable. For example, if the Notary leaks 3 bits of their keyshare, it gives the User no meaningful advantage in any attack, as she could have simply guessed the bits correctly with $1/2^3 = 12.5%$ probability and mounted the same attack.</p>
<p>Secondly, we observe that the Notary's keyshare is an <em>ephemeral secret</em>: it is only private for the duration of the User's TLS session. This implies two things:</p>
<ol>
<li>The User is free to learn the encryption key after she has received and committed to the TLS response. Thus, if the parties wait until the end of the TLS session to do maliciousness checks, then they can reap the benefits of the Notary having no private inputs.</li>
<li>Since the encryption key is not a long-term secret, it is okay if a malicious User prematurely learns the entire key, <em>so long as it is detected</em>. Thus, the parties are free to engage in potentially leaky MPC early on, so long as checks are performed at some point.</li>
</ol>
<h2 id="prelims"><a class="header" href="#prelims">Prelims</a></h2>
<ul>
<li>$p$ is the User's plaintext request</li>
<li>$k$ is the AES key</li>
<li>$[k]_1$ and $[k]_2$ are the User's and Notary's AES keyshares, respectively. That is, $k = [k]_1 \oplus [k]_2$.</li>
<li>$\mathsf{Enc}$ denotes the encryption algorithm used by the TLS session</li>
<li>$\mathsf{PRG}$ denotes a pseudorandom generator</li>
<li>$\mathsf{com}_x$ denotes a binding commitment to the value $x$</li>
</ul>
<h2 id="ideal-functionality"><a class="header" href="#ideal-functionality">Ideal functionality</a></h2>
<p>We define the ideal functionality we wish to instantiate. In words, the functionality uses the parties' keyshares to encrypt the User's TLS request, and send the ciphertext to both parties. The functionality then waits for the user to get and commit to the TLS response, and then releases the encryption key to the User.</p>
<p>Ideal functionality for ONESHOTENC:</p>
<ol>
<li>User → ℱ: $p, [k]_1$</li>
<li>Notary → ℱ: $[k]_2$</li>
<li>ℱ → User: $\mathsf{Enc}_k(p)$</li>
<li>ℱ → Notary: $\mathsf{Enc}_k(p)$</li>
<li>User → ℱ: $\mathsf{com}_\mathsf{resp}$</li>
<li>ℱ → User: $k$</li>
<li>ℱ → Notary: $\mathsf{com}_\mathsf{resp}$</li>
</ol>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>We now describe the protocol at a high level. It is based on Figure 1 of the <a href="https://www.cs.virginia.edu/%7Eevans/pubs/oakland2012/quidproquotocols.pdf">Dual-Execution (DualEx) technique</a> with a relaxation (see Step 3 below). We overcome DualEx's inherent 1-bit leakage by introducing a consistency check which the User performs on the Notary, thus removing the ability to leak the User's input. It is still possible for a malicious User to leak the Notary's input (i.e. the AES key share), but it gives her no meaningful advantage as per the first observation above.</p>
<h3 id="part-1"><a class="header" href="#part-1">Part 1</a></h3>
<p>To set up for dual-execution, the parties set up the OTs. Because we have a privacy-free step later, the Notary's OT needs to be opened up later, so we have the notary do a &quot;committed OT&quot; (see section 2 of <a href="https://eprint.iacr.org/2013/073">JKO13</a>), so that he can be forced to open the labels later on.</p>
<p>In the first step of the protocol, the User has to get her AES ciphertext from the Notary. The User does not trust the Notary (for privacy or integrity), and the User's data is far more sensitive to leakage than the Notary's. So the parties do an ordinary DualEx:</p>
<ol start="0">
<li>
<p>The User and Notary both garble a copy of the encryption circuit, and do OTs for each other. For committed OT the Notary constructs the input wire labels and OT encryption keys as $\mathsf{PRG}(\rho)$ where $\rho$ is a randomly sampled PRG seed, and sends $\mathsf{com}_\rho$ to the User after the OT is done.</p>
</li>
<li>
<p>The User sends her garbled encryption circuit and garbled wires for $[k]_1$ and $p$. She also sends the output decoding information.</p>
</li>
<li>
<p>The Notary uses his OT values to evaluate the circuit on $[k]_2$. He derives the encoded ciphertext $C$ and decodes it into ciphertext $c$ using output decoding information.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
</li>
<li>
<p>The Notary sends $C$ to the User.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>Step 3 is a relaxation of DualEx. In DualEx, the User would not learn the Notary's evaluation output at this point. As mentioned earlier, in TLSNotary protocol's setting, we are not worried that $C$ may leak the Notary's input, as long as this behaviour will be detected later. Also we are not worried about DualEx's inherent 1-bit leakage since it gives no meaningful advantage to the User as explained earlier. </p>
<p>There is no wiggle room for the User to exploit this relaxation because she is locked into using the inputs she received via OT in Step 0 and she has to pass the DualEx equality check which will follow later in Step 14.</p>
</li>
<li>
<p>As per DualEx, now the Notary knows what the User's encoded output should be, so the Notary computes $Check_n = H(w_B || W_B^{v_B})$ and keeps it.</p>
</li>
<li>
<p>The User decodes $C$ and derives the ciphertext $c$.</p>
</li>
</ol>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note that it is in keeping with the DualEx paper to allow a party to send the wrong output decoding information, or to provide different inputs to the two circuit evaluations. This does not affect the security of DualEx.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>A question may arise at this point re Step 3: why doesn't the Notary simply send $c$ to the User. The reason is that the Notary could send a maliciously crafted $c$: the Notary could flip a bit in $c$ (which translates into flipping a bit in the plaintext). The User would then forward the malicious $c$ to the server.</p>
</div>
<p>At this point, the Notary (even if malicious) has learned nothing about the key or the plaintext. He has only learned the ciphertext.</p>
<p>Also at this point, the User has learned the ciphertext, and, if malicious, has potentially learned the entire key $k$. As mentioned in the second observation above, it is okay if the User was malicious and learned $k$, but the Notary has to detect it and then abort the rest of the TLSNotary protocol. Before this step, the Notary waits for the User to complete their TLS session:</p>
<h3 id="part-2"><a class="header" href="#part-2">Part 2</a></h3>
<ol start="6">
<li>The User completes her TLS session and sends $\mathsf{com}_\mathsf{resp}$</li>
</ol>
<h3 id="part-3"><a class="header" href="#part-3">Part 3</a></h3>
<p>Now that the session is over and $[k]_2$ is no longer secret, the Notary can switch to privacy-free garbling for the second part of DualEx.</p>
<ol start="7">
<li>
<p>The Notary sends his garbled encryption circuit to the User, as well as the garbled wires for $[k]_2$. He also sends the output decoding information.</p>
</li>
<li>
<p>The User evaluates the circuit on $[k]_1$ and $p$, using the OT values from step 0, derives the encoded ciphertext $C'$ and decodes it into ciphertext $c$ using output decoding information.</p>
</li>
<li>
<p>As per DualEx, she computes $Check_u = H(w_A || W_A^{v_A})$ and sends a commitment $\mathsf{com}_{Check_u}$ to the Notary.</p>
<p>Note that at this stage the Notary could reveal $Check_n$ and the User would make sure that $Check_n == Check_u$. Then likewise the User would reveal $Check_u$ and the Notary would make sure that $Check_n == Check_u$.
As per the DualEx's inherent 1-bit leakage, the very act of performing the equality check would leak 1 bit of the User's input to a malicious Notary. To avoid the leakage, the User must first check the consistency of the Notary's OT and garbled circuits:</p>
</li>
<li>
<p>The Notary reveals all the wire labels and OT encryption keys by opening $\mathsf{com}_\rho$.</p>
</li>
<li>
<p>The User checks that the opening is correct, and that $\mathsf{PRG}(\rho)$ is consistent with the OT ciphertexts sent earlier by the Notary. On success, she opens her commitment, sending $C'$ and the commitment's randomness to the notary.</p>
<p>With the consistency check passed, the parties resume the DualEx's equality check:</p>
</li>
<li>
<p>The Notary send $Check_n$.</p>
</li>
<li>
<p>The User asserts that $Check_n == Check_u$. The User decommits $\mathsf{com}_{Check_u}$ by sending $Check_u$.</p>
</li>
<li>
<p>The Notary checks the decommitment and asserts that $Check_n == Check_u$.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computing-mac-in-2pc"><a class="header" href="#computing-mac-in-2pc">Computing MAC in 2PC</a></h1>
<ol>
<li><a href="protocol/2pc/mac.html#section1">What is a MAC</a></li>
<li><a href="protocol/2pc/mac.html#section2">How a MAC is computed in AES-GCM</a></li>
<li><a href="protocol/2pc/mac.html#section3">Computing MAC using secure two-party computation (2PC)</a> </li>
</ol>
<h2 id="1-what-is-a-mac"><a class="header" href="#1-what-is-a-mac">1. What is a MAC <a name="section1"></a></a></h2>
<p>When sending encrypted ciphertext to the Webserver, the User attaches a checksum to it. The Webserver uses this checksum to check whether the ciphertext has been tampered with while in transit. This checksum is known as the &quot;authentication tag&quot; and also as the &quot;Message Authentication Code&quot; (MAC).</p>
<p>The first few paragraphs of <a href="https://zsecurity.org/bit-flipping-attacks-against-cipher-block-chaining-algorithms/">this article</a> explain what would happen if there was no MAC: it would be possible for a malicious actor to modify the <strong>plaintext</strong> by flipping certain bits of the <strong>ciphertext</strong>.</p>
<h2 id="2-how-a-mac-is-computed-in-aes-gcm"><a class="header" href="#2-how-a-mac-is-computed-in-aes-gcm">2. How a MAC is computed in AES-GCM <a name="section2"></a></a></h2>
<p>In TLS the plaintext is split up into chunks called &quot;TLS records&quot;. Each TLS record is encrypted and a MAC is computed for the ciphertext. The MAC (in AES-GCM) is obtained by XORing together the <code>GHASH output</code> and the <code>GCTR output</code>. Let's see how each of those outputs is computed:</p>
<h4 id="21-ghash-output"><a class="header" href="#21-ghash-output">2.1 GHASH output</a></h4>
<p>The <code>GHASH output</code> is the output of the GHASH function described in the <a href="https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-38d.pdf">NIST publication</a> in section 6.4 in this way: &quot;In effect, the GHASH function calculates \(  \small{ X1•H^{m} ⊕ X2•H^{m−1} ⊕ ... ⊕ Xm−1•H^{2} ⊕ Xm•H } \)&quot;.</p>
<p>In other words, GHASH splits up the ciphertext into 16-byte blocks, each block is numbered \( \small{ X_1, X_2, ... }\) etc. There's also \( \small{H} \) which is called the <code>GHASH key</code>. We need to raise \( \small{H} \) to as many powers as there are blocks, i.e. if we have 5 blocks then we need 5 powers: \( \small{ H, H^2, H^3, H^4, H^5 } \). Each block is multiplied by the corresponding power and all products are summed together.</p>
<p>&quot;•&quot; is a special type of multiplication called <code>multiplication in a finite field</code> described in section 6.3 of the NIST publication. Below is the pseudocode for multiplying two 128-bit field elements <code>x</code> and <code>y</code> in a finite field:</p>
<p>Figure 1: multiplication in a finite field<a name="Figure_1"></a></p>
<pre><code>1. result = 0
2. R = 0xE1000000000000000000000000000000
3. bit_length = 128
4. for i=0 upto bit_length-1
5.    if y[i] == 1
6.       result ^= x
7. x = (x &gt;&gt; 1) ^ ((x &amp; 1) * R)
8. return result
</code></pre>
<p>⊕ is <code>addition in a finite field</code> and it is defined as XOR.</p>
<p>Standard math properties hold in finite field math, viz. commutative: \( \small{ a+b=b+a } \) and distributive: \( \small{ a(b+c)=ab+ac } \).</p>
<h4 id="21-gctr-output"><a class="header" href="#21-gctr-output">2.1 GCTR output</a></h4>
<p>The <code>GCTR output</code> is computed by simply AES-ECB encrypting a counter block with the counter set to 1 (the iv, nonce and AES key are the same as for the rest of the TLS record).</p>
<h2 id="3-computing-mac-using-secure-two-party-computation-2pc"><a class="header" href="#3-computing-mac-using-secure-two-party-computation-2pc">3. Computing MAC using secure two-party computation (2PC) <a name="section3"></a></a></h2>
<p>Below we introduce the protocol. At the start of the protocol each party has:</p>
<ol>
<li>ciphertext blocks \( \small{ X_1, X_2, ... } \).</li>
</ol>
<p>(the following items were obtained at an earlier stage of the TLSNotary protocol):</p>
<ol start="2">
<li>his XOR share of \( \small{ H } \): the <code>User</code> has \( \small{ H_u } \) and the <code>Notary</code> has \( \small{ H_n } \).</li>
<li>his XOR share of the <code>GCTR output</code>: the <code>User</code> has \( \small{ GCTR_u } \) and the <code>Notary</code> has \( \small{ GCTR_n } \).</li>
</ol>
<p>The goal of the protocol is to compute the MAC in such a way that neither party would learn the other party's share of \( \small{ H } \) i.e. the <code>GHASH key</code> share.</p>
<h4 id="31-example-with-one-ciphertext-block"><a class="header" href="#31-example-with-one-ciphertext-block">3.1 Example with one ciphertext block</a></h4>
<p>Suppose that the ciphertext consists of only 1 block \( \small{ X1 } \). The <code>GHASH_output</code> will be:</p>
<p>\( \small{ X_1•H = X_1•(H_u ⊕ H_n) = X_1•H_u ⊕ X_1•H_n } \)</p>
<p>The <code>User</code> and the <code>Notary</code> will compute locally the left and the right terms respectively. Then each party will XOR their result to the <code>GCTR output</code> share and will get their XOR share of the MAC:</p>
<p><code>User</code>  : \( \small{X_1 • H_u \quad ⊕ \quad CGTR_u = MAC_u} \)</p>
<p><code>Notary</code>: \( \small{X_1 • H_n \quad ⊕ \quad CGTR_n = MAC_n} \)</p>
<p>Finally, the <code>Notary</code> sends \( \small{MAC_n}\) to the <code>User</code> who obtains: </p>
<p>\( \small{ MAC = MAC_n \quad ⊕ \quad MAC_u} \)</p>
<h4 id="32-example-with-two-ciphertext-blocks-free-squaring"><a class="header" href="#32-example-with-two-ciphertext-blocks-free-squaring">3.2 Example with two ciphertext blocks. Free Squaring.</a></h4>
<p>Now, let's suppose that the ciphertext consists of 2 blocks \( \small{ X_1 }\) and \( \small{ X_2 }\). The <code>GHASH_output</code> will be:</p>
<p>\( \small{ X_1 • (H_u ⊕ H_n) ⊕ X_2 • H^2 } \)</p>
<p>The only unknown here is:</p>
<p>\( \small{ H^2 = (H_u ⊕ H_n)^2 = (H_u)^2 ⊕ 2(H_u • H_n) ⊕ (H_n)^2 = (H_u)^2 ⊕ (H_n)^2 } \)</p>
<p>The reason why the middle term \( \small{ 2(H_u•H_n) }\) disappeared is this: \( \small{2} \) is not a field element, so <code>multiplication in a finite field</code> cannot be applied to it. Instead, we substitute \( \small { 2(H_u•H_n) }\) with \( \small { (H_u • H_n) ⊕ (H_u • H_n) } \). Since ⊕ is defined as XOR, we are essentially XORing the value to itself and get 0. </p>
<p>To sum up, each party can locally square their share of \( \small{H}\) and get a share of \( \small{H^2}\). We call this method <code>Free Squaring</code> (&quot;free&quot; meaning &quot;without any communication cost&quot;). If e.g. the parties had their shares of \( \small{H^3}\) they could repeatedly perform <code>Free Squaring</code> to obtain their shares of \( \small{ H^6, H^{12}, H^{24}, H^{48}} \) etc.</p>
<h4 id="33-example-with-three-ciphertext-blocks-2pc-multiplication"><a class="header" href="#33-example-with-three-ciphertext-blocks-2pc-multiplication">3.3 Example with three ciphertext blocks. 2PC multiplication.</a></h4>
<p>Now, let's suppose that the ciphertext consists of 3 blocks \( \small {X_1, X_2, X_3} \) and the parties already performed <code>Free Squaring</code> and have their shares of \( \small{H^2} \). The <code>GHASH_output</code> will be:</p>
<blockquote>
<p>📝 <span style="color:red">In the following and elsewhere below \( \small{H^n_x} \) always refers to a sharing of \( \small{H^n} \) for party \( \small{x} \), and not
a sharing of \( \small{H} \) raised to the \( \small{n} \)th power, i.e. we deal with sharings of powers of \( \small{H} \) and not powers of
sharings of \( \small{H} \).</span></p>
</blockquote>
<p>\( \small{ X_1•(H_u ⊕ H_n) ⊕ X_2•(H^2_u ⊕ H^2_n) ⊕ X_3•H^3 } \)</p>
<p>Observe that:</p>
<p>\( \small { H^3 = H^2•H = (H^2_u ⊕ H^2_n) • (H_u ⊕ H_n) = (H^2_u • H_u) ⊕ (H^2_u • H_n) ⊕ (H^2_n • H_u) ⊕ (H^2_n • H_n) } \)</p>
<p>The 1st and the 4th terms can be computed locally by the <code>User</code> and the <code>Notary</code> respectively. Only the 2nd and the 3rd terms need to be computed using <code>2PC</code>.</p>
<p>In <a href="protocol/2pc/mac.html#Figure_1">Figure 1</a> it can be seen that for each of the 128 loop iterations, the value of <code>x</code> changes independently of <code>y</code>. This allows <code>PartyX</code> (the party who has the <code>x</code> value) to compute a table (we call it an <code>Xtable</code>) of 128 rows where each row's value equals the value of <code>x</code> in one of the 128 iterations. Then, depending on the bit of <code>y</code>, the corresponding <code>Xtable</code> row will either be XORed to the result or be ignored.</p>
<p>The protocol below which we dub <code>Mul_2PC</code> shows how to perform <code>multiplication in a finite field</code> using <a href="https://en.wikipedia.org/wiki/Oblivious_transfer#1%E2%80%932_oblivious_transfer">1-out-of-2 Oblivious Transfer</a> (OT). <code>PartyX</code> computes an <code>Xtable</code> with 4 rows and masks each row's value as well as the 0's value. <code>PartyY</code> is the OT receiver and receives a masked <code>Xtable</code> row (if the bit of <code>y</code> is 1) or a masked 0 (if the bit of <code>y</code> is 0). We illustrate <code>Mul_2PC</code> for a 4-bit value:</p>
<img src="protocol/2pc/mul2pc.png" width="800">
<p>Note how neither party has the actual result of the multiplication i.e. (row1 XOR row4). The parties only have their XOR shares of the result.</p>
<p>Using <code>Free Squaring</code> and <code>Mul_2PC</code>, the parties can start with their shares of \( \small{ H } \) and compute <code>GHASH output</code> for any ciphertext size.</p>
<h4 id="34-example-with-nine-ciphertext-blocks-block-aggregation"><a class="header" href="#34-example-with-nine-ciphertext-blocks-block-aggregation">3.4 Example with nine ciphertext blocks. Block Aggregation.</a></h4>
<p>We present an optimization we call <code>Block Aggregation</code> which allows to decrease both the amount of rounds of communication between the parties and the amount of OT instances.</p>
<p>Suppose that the ciphertext consists of 9 blocks \( \small{ X_1, ..., X_9 } \) and that the parties already ran <code>Mul_2PC</code> to obtain their shares of \( \small{ H^3 } \). After performing <code>Free Squaring</code> on their shares of \( \small{ H^2 } \) and \( \small{ H^3 } \), here are all the shares of powers which each party has:
\( \small{ H, H^2, H^3, H^4, H^6, H^8 } \)</p>
<p>Naively, the parties could use <code>Mul_2PC</code> to compute their shares of \( \small{ H^5, H^7, H^9 } \) using 3 invocations of <code>Mul_2PC</code>. We now show how this can be done with 2 invocations of <code>Mul_2PC</code>. </p>
<p>Recalling that:</p>
<p>\( \small{ H^5•X_5 = (H^4_n ⊕ H^4_u)(H_n ⊕ H_u)X_5 = H^4_nH_nX_5 ⊕ \color{blue}{H^4_nH_uX_5} ⊕ \color{blue}{H^4_uH_nX_5} ⊕ H^4_uH_uX_5 } \)
\( \small{ H^7•X_7 = (H^6_n ⊕ H^6_u)(H_n ⊕ H_u)X_7 = H^6_nH_nX_7 ⊕ \color{blue}{H^6_nH_uX_7} ⊕ \color{blue}{H^6_uH_nX_7} ⊕ H^6_uH_uX_7 } \)
\( \small{ H^9•X_9 = (H^8_n ⊕ H^8_u)(H_n ⊕ H_u)X_9 = H^8_nH_nX_9 ⊕ \color{blue}{H^8_nH_uX_9} ⊕ \color{blue}{H^8_uH_nX_9} ⊕ H^8_uH_uX_9 } \)</p>
<p>Above, we <span style="color:blue">highlighted</span>  all terms which the parties cannot compute locally and must compute using <code>Mul_2PC</code>. The sum of the highlighted terms can be represented as:</p>
<p>\( \small{ H^4_n\color{blue}{H_u}X_5 ⊕ H^4_u\color{red}{H_n}X_5 ⊕ H^6_n\color{blue}{H_u}X_7 ⊕ H^6_u\color{red}{H_n}X_7 ⊕ H^8_n\color{blue}{H_u}X_9 ⊕ H^8_u\color{red}{H_n}X_9 = \\ \color{blue}{H_u}(H^4_nX_5 ⊕ H^6_nX_7 ⊕ H^8_nH_9) ⊕ \color{red}{H_n}(H^4_uX_5 ⊕ H^6_uX_7 ⊕ H^8_uH_9) } \)</p>
<p>The terms in brackets can be locally computed by the respective party. Let's call the term on the left <code>termN</code> and the term on the right <code>termU</code>. Then we can re-write the above to show that only 2 <code>Mul_2PC</code> are needed:</p>
<p>\( \small{ \color{blue}{H_u} • termN ⊕ \color{red}{H_n} • termU } \)</p>
<p>Each party will combine his shares from <code>Mul_2PC</code> with all the terms he computed locally earlier and will obtain his share of the <code>GHASH_block</code>.</p>
<h4 id="35-security-considerations"><a class="header" href="#35-security-considerations">3.5 Security considerations</a></h4>
<p><code>PartyX</code> may act maliciously and craft the <code>Xtable</code> in a way which leaks bits of y through <code>PartyY</code>s output of <code>Mul_2PC</code>. For this reason, the role of <code>GCTR_output</code> share is crucial in ensuring malicious security of the protocol. The <code>GCTR_output</code> share serves essentially as a one-time pad masking <code>PartyY</code>'s potentially leaky <code>GHASH_output</code> from <code>PartyX</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
